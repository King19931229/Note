【2017-09-18】C++内存优化技巧
union
{
	// 定义多个互斥struct
	struct A
	{
	};
	struct B
	{
	};
	//......
};

【2017-09-19】【1】C++11 新for
int ary[] = {1,3,1,4,};
for(int nData : ary)
{
	printf("%d\n", nData);
}

for(int &nData : ary)
{
	nData = 0;
	printf("%d\n", nData);
}

// 注意auto类型不是int
std::vector<int> vec;
vec.push_back(1); vec.push_back(3); vec.push_back(1); vec.push_back(4);

for(auto nData : vec)
{
	printf("%d\n", nData);
}

for(int nData : vec)
{
	printf("%d\n", nData);
}

for(auto &it : vec)
{
	it = 0;
	printf("%d\n", it);
}

std::map<int, int> map;
map.insert(std::pair<int, int>(10, 10));

// 注意auto类型std::map<int, int>::value_type即std::pair<int, int>
for(auto pair : map)
{
	printf("%d %d\n", pair.first, pair.second);
}

for(std::map<int, int>::value_type pair : map)
{
	printf("%d %d\n", pair.first, pair.second);
}

//所以for(auto it : container) 中 auto类型为container元素类型而非迭代器

【2017-09-19】【2】umdh查内存泄漏
1.首先安装好WinDbg
2.然后用任务管理员权限打开cmd
3.cd到WinDbg目录
4.执行 set _NT_SYMBOL_PATH="%windir%\symbols";AppPath目标程序符号文件位置;
5.打开App.exe
6.执行 gflags -i App.exe +ust (App为已经开启的进程 成功执行后屏幕会输出一些东西)
7.执行 umdh.exe -pn:App.exe -f:D:/Output/FirstDump.txt
8.继续运行App.exe执行一些操作
9.执行 umdh.exe -pn:App.exe -f:D:/Output/SecondDump.txt
10.执行 umdh.exe D:/Output/FirstDump.txt D:/Output/SecondDump.txt -f:D:/Output/Result.txt
11.Profile结果在Result.txt里

【2017-09-20】内存泄漏检查
// http://blog.csdn.net/bluehawksky/article/details/39841975
// http://www.cnblogs.com/findumars/p/5353538.html
// http://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html
#ifdef MEMORY_DUMP_DEBUG

#	ifdef _WIN32
#		define _CRTDBG_MAP_ALLOC
#		include <stdlib.h>
#		include <crtdbg.h>

//	开始检测内存泄漏
//	DUMP_MEMORY_LEAK_BEGIN开始跟踪内存分配
#	define DUMP_MEMORY_LEAK_BEGIN() {_CrtSetDbgFlag (_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);}
//	结束检测内存泄漏
//	DUMP_MEMORY_LEAK_END是清空内存分配跟踪
#	define DUMP_MEMORY_LEAK_END() {_CrtDumpMemoryLeaks(); _CrtSetDbgFlag(0);}
#	define DUMP_MEMORY_STATUS() {_CrtMemState s; _CrtMemCheckpoint(&s); _CrtMemDumpStatistics(&s);}

#	else
//	https://en.wikipedia.org/wiki/Mtrace
#	include <stdlib.h>
#	include <mcheck.h>
#	define DUMP_MEMORY_LEAK_BEGIN() {mtrace();}
#	define DUMP_MEMORY_LEAK_END() {muntrace();}
#	define DUMP_MEMORY_STATUS()

#	endif

#else

#	define DUMP_MEMORY_LEAK_BEGIN()
#	define DUMP_MEMORY_LEAK_END()
#	define DUMP_MEMORY_STATUS()

#endif//MEMORY_DUMP_DEBUG
【2017-09-21】【1】命令队列
如果一个方法要加入命令队列然后轮询
但是方法未执行时调用者不能返回 必须阻塞等待
这时候可以用信号量解决
Sem sem;
CommandList.push([&sem](/*...*/)
{
	//DoSomWork
	sem.Notify();
}
sem.Wait();

【2017-09-21】【2】状态转移
CAS做状态转移
atomic state;
if(state.cas(exp, tar))
{
	//状态转移成功
}

【2017-09-22】【1】回顾operator new
// 覆盖全局operator new
void *operator new(size_t size)
{
	return malloc(size);
}
void operator delete(void* p)
{
	free(p);
}
// 覆盖全局operator new[]
void *operator new[](size_t size)
{
	return malloc(size);
}
void operator delete[](void* p)
{
	free(p);
}

// placement new
void *operator new(size_t size, /*用户自定义参数*/void* pMemory, int nLine, const char* pFileName)
{
	printf("%d %s\n", nLine, pFileName);
	return pMemory;
}

void* p = operator new(sizeof(int));// new int;
int *newPtr = new(p, __LINE__, __FILE__) int;
语法: ptr = new (参数表) 构造函数
【2017-09-22】【2】宏定义# ##
#define TOSTR(x) #x //量化为字符串
#define LINK_X_Y(x, y) x##y //宏连接

puts(TOSTR(100));// 100
puts(LINK_X_Y(TOSTR(12), TOSTR(34))); //1234
puts(TOSTR(LINK_X_Y(56, 78))); // LINK_X_Y(56, 78) 直接把#后面的变成字符串了

【2017-09-25】函数修饰
__stdcall 约定被调用函数负责对函数参数退栈 Windows回调函数只能使用该约定
__cdecl 约定调用者负责函数参数退栈 因此可变函数参数只能使用该约定
C和C++默认约定是__cdecl

可以这样检测默认约定
int __cdecl add(int a, int b);
int add(int a, int b)
{
    return a + b;
}
IDE提示出错-->默认约定是__cdecl
主要如果使用__stdcall要保证声明与实现都有__stdcall标志
还有约定函数指针时也要注意匹配

【2017-09-26】C++ inl文件
http://blog.csdn.net/business122/article/details/9770019
内联函数和模版的声明和定义必须放在一起
但是如果数量太多影响阅读 可以把实现抽出来放到inl文件里
然后头文件在结尾include该inl文件

【2017-09-26】C++ 命名空间
namespace
{
	void Test()
	{
		puts("namespace");
	}
}
void Test()
{
	puts("global");
}
int main()
{
	/*
	Test();
	error C2668: “Test”: 对重载函数的调用不明确
	: 可能是“void Test(void)”
	: 或       “void `anonymous-namespace'::Test(void)”
	尝试匹配参数列表“(void)”时
	*/
	::Test();//输出global
}

【2017-09-27】#pragma push_macro #pragma pop_macro
//http://blog.csdn.net/ixsea/article/details/7976627
>1.
#define int double
	printf("%d\n", sizeof(int)); // 8
#pragma push_macro("int")// 将int的定义入栈
#undef int // 取消该宏定义
	printf("%d\n", sizeof(int)); // 4
#pragma pop_macro("int")// 恢复入栈前int的定义
	printf("%d\n", sizeof(int)); // 8

#pragma push_macro("int")
	printf("%d\n", sizeof(int)); // 8
#pragma pop_macro("int")
>2.
#define A 1
#define B 2

#pragma push_macro("A")
#pragma push_macro("B")
#pragma pop_macro("A")
#pragma pop_macro("B")

printf("%d %d\n", A, B);// 1 2
所以入栈 出栈是独立的
>3.
在三方库源码中，我们经常看到这样的代码：
#pragma push_macro("new")
#undef new
// do something with new
......
#pragma pop_macro("new")
它的作用就是将宏定义new压入栈并取消它的定义
如此一来new的本来含义便获得了恢复
使用完毕后将宏定义new弹出栈 恢复宏定义