【2020-01-27】C++ const 与 auto 结合使用
auto 为 const 结合使用时候
无论是 auto const 或者 const auto
编译都会理解成auto const
若auto为指针 表达意义都是 指针指向不能改变 而指针的数据是允许改变的
若auto为引用 表达意义都是 引用数据不允许改变

例1:
int* acquire_pointer()
{
	return new int;
}

void release_pointer(const int* p)
{
	delete p;
}

int* const p = acquire_pointer();
// const 在 * 右边
// 指针指向数据值允许改变
*p = 1;
release_pointer(p);
// const 在 * 右边
// 指针指向不能改变
// p = nullptr;

const int* p2 = acquire_pointer();
// const 在 * 左边
// 指针指向数据值不允许改变
// *p2 = 1;
release_pointer(p2);
// const 在 * 左边
// 指针指向能改变
p2 = nullptr;

auto p3 = acquire_pointer();
// auto 为 int*
*p3 = 1;
release_pointer(p3);
// auto 为 int*
p3 = nullptr;

/*
auto 为 const 结合使用时候
如果auto表示的是指针类型 auto const 与 const auto
均表示指针为常量 因此表达意义都是指针指向不能改变
而指针的数据是允许改变的
*/

const auto p4 = acquire_pointer();
// auto 为 int*
// p4 完整类型为 int* const
// const 在 * 右边
// 指针指向数据值允许改变
*p4 = 1;
release_pointer(p4);
// auto 为 int*
// p4 完整类型为 int* const
// 指针指向不能改变
// p4 = nullptr;

auto const p5 = acquire_pointer();
// p5 类型跟 p4 完全一样
// 指针指向数据值允许改变
*p5 = 1;
release_pointer(p5);
// p5 类型跟 p4 完全一样
// 指针指向不能改变
// p5 = nullptr;

例2:
/*
auto 为 const 结合使用时候
如果auto表示的是引用类型 auto const 与 const auto
均表示引用为常量 因此表达意义都是引用数据不允许改变
*/
int num = 0;

{
	// n0 与 n1 表达相同意义
	// 类型 const int& 与 int const& 没有区别
	int const& n0 = num;
	const int& n1 = num;
	// ++n0;
	// ++n1;
}

{
	// n0 类型为 int&
	auto& n0 = num;
	++n0;

	auto const& n1 = num;
	// n1被const修饰 值不允许改变
	// n1完整类型为 int const& (与 const int& 无区别)
	// ++n1;

	const auto& n2 = num;
	// n2被const修饰 值不允许改变
	// n2完整类型为 const int& (与 int const& 无区别)
	// ++n2;
}