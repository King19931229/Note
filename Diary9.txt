【2020-01-27】C++ const 与 auto 结合使用
auto 为 const 结合使用时候
无论是 auto const 或者 const auto
编译都会理解成auto const
若auto为指针 表达意义都是 指针指向不能改变 而指针的数据是允许改变的
若auto为引用 表达意义都是 引用数据不允许改变

例1:
int* acquire_pointer()
{
	return new int;
}

void release_pointer(const int* p)
{
	delete p;
}

int* const p = acquire_pointer();
// const 在 * 右边
// 指针指向数据值允许改变
*p = 1;
release_pointer(p);
// const 在 * 右边
// 指针指向不能改变
// p = nullptr;

const int* p2 = acquire_pointer();
// const 在 * 左边
// 指针指向数据值不允许改变
// *p2 = 1;
release_pointer(p2);
// const 在 * 左边
// 指针指向能改变
p2 = nullptr;

auto p3 = acquire_pointer();
// auto 为 int*
*p3 = 1;
release_pointer(p3);
// auto 为 int*
p3 = nullptr;

/*
auto 为 const 结合使用时候
如果auto表示的是指针类型 auto const 与 const auto
均表示指针为常量 因此表达意义都是指针指向不能改变
而指针的数据是允许改变的
*/

const auto p4 = acquire_pointer();
// auto 为 int*
// p4 完整类型为 int* const
// const 在 * 右边
// 指针指向数据值允许改变
*p4 = 1;
release_pointer(p4);
// auto 为 int*
// p4 完整类型为 int* const
// 指针指向不能改变
// p4 = nullptr;

auto const p5 = acquire_pointer();
// p5 类型跟 p4 完全一样
// 指针指向数据值允许改变
*p5 = 1;
release_pointer(p5);
// p5 类型跟 p4 完全一样
// 指针指向不能改变
// p5 = nullptr;

例2:
/*
auto 为 const 结合使用时候
如果auto表示的是引用类型 auto const 与 const auto
均表示引用为常量 因此表达意义都是引用数据不允许改变
*/
int num = 0;

{
	// n0 与 n1 表达相同意义
	// 类型 const int& 与 int const& 没有区别
	int const& n0 = num;
	const int& n1 = num;
	// ++n0;
	// ++n1;
}

{
	// n0 类型为 int&
	auto& n0 = num;
	++n0;

	auto const& n1 = num;
	// n1被const修饰 值不允许改变
	// n1完整类型为 int const& (与 const int& 无区别)
	// ++n1;

	const auto& n2 = num;
	// n2被const修饰 值不允许改变
	// n2完整类型为 const int& (与 int const& 无区别)
	// ++n2;
}

【2020-2-12】C++ std::forward
// https://www.jianshu.com/p/b90d1091a4ff
// https://blog.csdn.net/coolwriter/article/details/80970718
当我们将一个右值引用传入函数时 他在实参中有了命名 所以继续往下传或者调用其他函数时
根据C++标准的定义 这个参数变成了一个左值 那么他永远不会调用接下来函数的右值版本
这可能在一些情况下造成拷贝。为了解决这个问题 C++11引入了完美转发
根据右值判断的推倒 调用forward传出的值
若原来是一个右值 那么他转出来就是一个右值 否则为一个左值
例:
#include <cstdio>
#include <algorithm>

template<typename T2>
void TemplateRefFunc(T2&& t)
{
	printf("rvalue reference\n");
	t = (T2)1;
}

template<typename T2>
void TemplateRefFunc(T2& t)
{
	printf("lvalue reference\n");
	t = (T2)0;
}

template<typename T>
void UniversalTemplateForwardFunc(T&& t)
{
	TemplateRefFunc(std::forward<T>(t));
}

template<typename T>
void UniversalTemplateFunc(T&& t)
{
	TemplateRefFunc(t);
}

int main()
{
	printf("test case 1:\n");
	{
		int val = 0;
		int &&val2 = std::move(val);
		int &val3 = val;

		printf("val a value\n");
		printf("val2 is a rvalue reference\n");
		printf("val3 is a lvalue reference\n");

		printf("call TemplateRefFunc(std::forward<decltype(val)>(val)): ");
		TemplateRefFunc(std::forward<decltype(val)>(val));
		printf("call TemplateRefFunc(std::forward<decltype(val2)>(val2)): ");
		TemplateRefFunc(std::forward<decltype(val2)>(val2));
		printf("call TemplateRefFunc(std::forward<decltype(val3)>(val3)): ");
		TemplateRefFunc(std::forward<decltype(val3)>(val3));
	}
	printf("test case 2:\n");
	{
		int val = 0;
		int &&val2 = std::move(val);
		printf("val a value\n");
		printf("val2 is a rvalue reference\n");
		printf("call UniversalTemplateForwardFunc(val): ");
		UniversalTemplateForwardFunc(val);
		printf("call UniversalTemplateForwardFunc(val2): ");
		UniversalTemplateForwardFunc(val2);
		printf("call UniversalTemplateForwardFunc(std::move(val2)): ");
		UniversalTemplateForwardFunc(std::move(val2));
	}
	printf("test case 3:\n");
	{
		int val = 0;
		int &&val2 = std::move(val);
		printf("val is a value\n");
		printf("val2 is a rvalue reference\n");
		printf("call UniversalTemplateFunc(val): ");
		UniversalTemplateFunc(val);
		printf("call UniversalTemplateFunc(val2): ");
		UniversalTemplateFunc(val2);
		printf("call UniversalTemplateFunc(std::move(val2)): ");
		UniversalTemplateFunc(std::move(val2));
	}
	return 0;
}
输出:
test case 1:
val a value
val2 is a rvalue reference
val3 is a lvalue reference
call TemplateRefFunc(std::forward<decltype(val)>(val)): rvalue reference
call TemplateRefFunc(std::forward<decltype(val2)>(val2)): rvalue reference
call TemplateRefFunc(std::forward<decltype(val3)>(val3)): lvalue reference
test case 2:
val a value
val2 is a rvalue reference
call UniversalTemplateForwardFunc(val): lvalue reference
call UniversalTemplateForwardFunc(val2): lvalue reference
call UniversalTemplateForwardFunc(std::move(val2)): rvalue reference
test case 3:
val is a value
val2 is a rvalue reference
call UniversalTemplateFunc(val): lvalue reference
call UniversalTemplateFunc(val2): lvalue reference
call UniversalTemplateFunc(std::move(val2)): lvalue reference

【2020-2-13】C++ 复制构造 移动构造
1.类定义复制构造函数后 默认的移动构造函数会被删除
template<typename T>
T Call()
{
	T a;
	return a;
}

class Test
{
protected:
public:
	Test()
	{
		printf("test default ctor\n");
	}
	Test(const Test& rhs)
	{
		printf("test lvalue ctor\n");
	}
};

int main()
{
	Call<Test>();
}
运行期输出:
test default ctor
test lvalue ctor
(调用到复制构造函数 因此没有调用到移动构造函数)

2.类定义移动构造函数后 默认的复制构造函数会被删除
例:
template<typename T>
T Call()
{
	T a;
	T b(a);
	return a;
}

class Test
{
protected:
public:
	Test()
	{
		printf("test default ctor\n");
	}
	Test(Test&& rhs)
	{
		printf("test rvalue ctor\n");
	}
};

int main()
{
	Call<Test>();
}
编译器输出:
C2280	“Test::Test(const Test &)”: 尝试引用已删除的函数

3.对象按值返回 会优先匹配移动构造函数
例:
template<typename T>
T Call()
{
	T a;
	return a;
}

class Test
{
protected:
public:
	Test()
	{
		printf("test default ctor\n");
	}
	Test(const Test& rhs)
	{
		printf("test lvalue ctor\n");
	}
	Test(Test&& rhs)
	{
		printf("test rvalue ctor\n");
	}
};

int main()
{
	Call<Test>();
}

运行期输出:
test default ctor
test rvalue ctor

4.默认的移动构造函数和复制构造函数会对对象的成员调用其对应的移动构造或者复制构造
例1:
class Small
{
protected:
public:
	Small()
	{
		printf("small default ctor\n");
	}
	Small(const Small& rhs)
	{
		printf("small lvalue ctor\n");
	}
	Small(Small&& rhs)
	{
		printf("small rvalue ctor\n");
	}
};

class Big
{
protected:
	Small small;
public:
	Big()
	{
		printf("big default ctor\n");
	}
};

template<typename T>
T Call()
{
	T a;
	return a;
}

int main()
{
	Call<Big>();
}
运行期输出:
small default ctor
big default ctor
small rvalue ctor
(调用到Big的默认移动构造 其实现则对对象成员同样执行移动构造)

例2:
class Small
{
protected:
public:
	Small()
	{
		printf("small default ctor\n");
	}
	Small(const Small& rhs)
	{
		printf("small lvalue ctor\n");
	}
	Small(Small&& rhs)
	{
		printf("small rvalue ctor\n");
	}
};

class Big
{
protected:
	Small small;
public:
	Big()
	{
		printf("big default ctor\n");
	}
	Big(const Big& rhs) = default;
};

template<typename T>
T Call()
{
	T a;
	return a;
}

int main()
{
	Call<Big>();
}
运行期输出:
small default ctor
big default ctor
small rvalue ctor
(调用到Big的默认复制构造 其实现则对对象成员同样执行复制构造)