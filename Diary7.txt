【2019-05-22】pyinstaller
pyinstaller可以把py文件转化为可执行文件
可以使用pyi-makespec生成中间文件,再用pyinstaller转化为可执行文件
也可以使用直接pyinstaller转化为可执行文件
注意使用--hidden-import参数保证隐式import的模块也被打包
# https://pythonhosted.org/PyInstaller/man-pages.html
# https://blog.csdn.net/king_mountian/article/details/81664599
例:
import os
import subprocess

def makespec(outname):
	# 直接转化为可执行文件
	# cmd = "pyinstaller"
	cmd = "pyi-makespec"
	args = [cmd]
	base = "."
	# 把所有的模块都加入到-hidden-import里
	for root, dirs, files in os.walk(base):
		for name in files:
			if name.endswith(".py"):
				module = root.replace("\\", ".").lstrip(".")
				if module:
					hidden_import = module + "." + name[:-3]
				else:
					hidden_import = name[:-3]
				args.append("--hidden-import=%s" % hidden_import)
	args.append("-F")
	res = os.path.abspath("res").replace("\\", "/")
	args.append("--paths=%s" % res)
	args.append("-n%s" % outname)
	args.append("makelink_gui.py")
	subprocess.call(args, shell=True)

def build():
	name = "MakeLink"
	makespec(name)
	subprocess.call(r"pyinstaller %s.spec" % name, shell=True)

def main():
	build()

if __name__ == '__main__':
	main()
	
【2019-05-23】【1】python print >> 重定向
# https://blog.csdn.net/xyh421/article/details/79513259
这种方式基于print语句的扩展形式
即print >> obj, expr
其中，obj为一个file-like(尤其是提供write方法的)对象
为None时对应标准输出(sys.stdout) expr将被输出到该文件对象中
例:
class SysOutHooker(object):
	def __init__(self, org):
		self.org = org
	def write(self, msg):
		msg = msg.rstrip("\r\n")
		if not msg:
			return
		self.org.write("hooker: %s\n" % msg)

hooker = SysOutHooker(sys.stdout)
print >> hooker, "test message"
print "test message"
输出:
hooker: test message
test message

【2019-05-23】【2】python subprocess 重定向
# https://www.cnblogs.com/zhoug2020/p/5079407.html
subprocess.Popen传入stdout, stderr控制子进程重定向
stdout = None 或者 stderr = None 表示子进程不会做任何重定向工作 子进程的文件描述符会继承父进程的
stderr = subprocess.STDOUT 表示子进程的标准错误也输出到标准输出
stdout = subprocess.PIPE 或者 stderr = subprocess.PIPE 则表示需要创建一个新的管道给子进程进行重定向

对sys.stdout和sys.stderr指定fileobj不会影响到进程的重定向
只会影响到python里输出的重定向
比如普通print之于sys.stdout traceback之于sys.stderr
例:
test.py [win32]:

class SysOutHooker(object):
	def __init__(self, org):
		self.org = org
	def write(self, msg):
		pass

# 这里是设置python输出钩子 不是进程输出重定向
hooker = SysOutHooker(sys.stdout)
sys.stdout = hooker
err_hooker = SysOutHooker(sys.stderr)
sys.stderr = err_hooker

print "set stderr = None: "
# subprocess.Popen 设置的stdout stderr 继承父进程 即是控制台输出
p = subprocess.Popen(["echo", "echo test"], shell = True, stdout = None, stderr = None, universal_newlines = True)
p = subprocess.Popen(["wrongcommand"], shell = True, stdout = None, stderr = None, universal_newlines = True)
p.wait()
print "p.stdout", p.stdout
print "p.stderr", p.stderr

print "set stderr = subprocess.STDOUT: "
# subprocess.Popen 设置的stdout继承父进程 stderr定向到stdout 即是控制台输出
p = subprocess.Popen(["echo", "echo test"], shell = True, stderr = subprocess.STDOUT, universal_newlines = True)
p = subprocess.Popen(["wrongcommand"], shell = True, stderr = subprocess.STDOUT, universal_newlines = True)
p.wait()
print "p.stdout", p.stdout
print "p.stderr", p.stderr

print "set stderr = subprocess.PIPE: "
# subprocess.Popen 设置的stdout stderr 输出到管道中
p = subprocess.Popen(["echo", "echo test"], shell = True, stdout = subprocess.PIPE, stderr = subprocess.PIPE, universal_newlines = True)
p = subprocess.Popen(["wrongcommand"], shell = True, stdout = subprocess.PIPE, stderr = subprocess.PIPE, universal_newlines = True)
p.wait()
print "p.stdout", p.stdout
print "p.stderr", p.stderr

【执行 python test.py】:
输出:
"echo test"
'wrongcommand' 不是内部或外部命令，也不是可运行的程序
或批处理文件。
"echo test"
'wrongcommand' 不是内部或外部命令，也不是可运行的程序
或批处理文件。

【执行 python test.py 2> nul 2>&1】
输出:
"echo test"
'wrongcommand' 不是内部或外部命令，也不是可运行的程序
或批处理文件。
"echo test"
'wrongcommand' 不是内部或外部命令，也不是可运行的程序
或批处理文件。

【执行 python test.py > nul 2>&1】:
没有任何输出

【2019-05-23】【2】python subprocess 重定向到PIPE卡死
# https://blog.csdn.net/xiaoxianerqq/article/details/78864330
# https://www.cnblogs.com/chybot/p/5176118.html
使用subprocess.Popen 重定向到subprocess.PIPE 如果管道内容太多
而且使用wait等待子进程结束 则可能会卡死
所以使用PIPE时不要使用wait而要使用communicate

【2019-05-26】创建与删除软链接和硬链接
1.linux
	1.1 给文件创造硬链接
	ln SourceFile DestFile
	1.2 给文件创造软链接
	ln -s SourceFile DestFile
	1.3 给文件夹创造硬链接(通常都会因为操作系统链接机制限制而失败[操作系统不支持])
	ln -d SourceFolder DestFolder
	1.4 给文件夹创造软链接
	ln -s SourceFolder DestFolder
2.windows
	2.1 给文件创造硬链接
	mkdir /H DestFile SourceFile
	2.2 给文件创造软链接
	mkdir DestFile SourceFile
	2.3 给文件夹创造硬链接 [操作系统不支持]	
	2.4 给文件夹创造软链接
	mkdir /D DestFile SourceFile

3.python下删除符号链接目录坑

在windows下给文件夹创建软链接后
如果用python的shutil.rmtree删除链接结果 会导致即使删除后目标文件夹(链接结果)被删除
源文件夹还保留 但是源文件夹里的文件与文件夹会全部丢失 这个应该是shutil.rmtree的bug
如果使用os.remove则会报WindowsError: [Error 5] 
如果使用os.removedirs(其本身功能为只能递归删除空文件夹)则不会出现此问题

linux下如果调用os.removedirs会报OSError: [Errno 20] Not a directory
调用shutil.rmtree则会报raise OSError("Cannot call rmtree on a symbolic link")
os.remove则不会报任何错误

另外python的os.symlink只有在linux下有效 在windows下连接口都没有
所以对链接的操作最好还是调用bat命令或者shell命令执行

windows下
删除符号链接目录 rmdir DestFolder
删除符号链接文件 del DestFile
linux下符号链接目录与符号链接文件 rm DestFolder

4.删除源文件坑
还有无论windows下还是linux下给一个文件(设为Source)创建了硬链接(设为HardResult)
和软链接(设为SoftResult)后 此时即使源文件在操作系统的引用计数已经+1了
但是如果删除了源文件(Source)后 软链接(SoftResult)还是会实效
证明软链接在两个操作系统上都是根据路径来链接的

【2019-05-30】【1】python subprocess 重定向到PIPE同时一直取出PIPE的输出
out = []
err = []
p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
for line in iter(p.stdout.readline, b''):
	line = line.rstrip('\n')
	line = line.rstrip('\r')
	out.append(line)
	out = '\n'.join(out)
	p.stdout.close()

for line in iter(p.stderr.readline, b''):
	line = line.rstrip('\n')
	line = line.rstrip('\r')
	err.append(line)
	err = '\n'.join(err)
	p.stderr.close()

p.wait()

【2019-05-30】【2】Qt使用QStandardItemModel实现自定义树形控件需求
TEST_NODE = {
	'src':
	{
		'Package':
		{
			'Char': {},
			'MapConfig': {},
			'Repository': {},
			'Text': {},
			'Sounds': {},
			'Video':{},
			'Worlds': {}
		}
	},
	'res':{}
}

# Qt QStandardItemModel封装了大部分树形model需要的需求
# QStandardItemModel使用到了QStandardItem控件
# 可以通过QStandardItem控件的setData(..., QtCore.Qt.UserRole)设置userdata
# 可以使用itemFromIndex接口从index获取具体QStandardItem
# 通过QStandardItem的data接口从而获取到控件的userdata
class MyTreeModel(QtGui.QStandardItemModel):
	def __init__(self, parent, dict_data):
		super(MyTreeModel, self).__init__()
		self.dict_data = dict_data
		self.build(self.invisibleRootItem(), self.dict_data)

	def build(self, parent_item, dict_data):
		for key, value in dict_data.iteritems():
			item = QtGui.QStandardItem(key)
			item.setData(value, QtCore.Qt.UserRole)
			parent_item.appendRow(item)
			self.build(item, value)

# 如果使用直接使用QAbstractItemModel实现树形model需要的需求会十分麻烦
# 因为通常要在QAbstractItemModel返回的QModelIndex存下internalPointer
# 而python里创建QModelIndex传入python对象作为指针通常会闪退
# 而且还要实现一些QAbstractItemModel的纯虚函数
# class MyTreeModel(QtCore.QAbstractItemModel):
# 	def __init__(self, parent, dict_data):
# 		super(MyTreeModel, self).__init__()
# 		self.dict_data = dict_data

# 	def index(self, row, column, parent_index):
# 		ret = self.createIndex(row, column)
# 		return ret

# 	def parent(self, child_index):
# 		return QtCore.QModelIndex()

# 	def columnCount(self, parent_index):
# 		return 1

# 	def rowCount(self, parent_index):
# 		if not parent_index.isValid():
# 			return 1
# 		return 0

# 	def data(self, index, role):
# 		if role == QtCore.Qt.DisplayRole:
# 			return "Test"

class MyTreeView(QtGui.QTreeView):
	def mouseReleaseEvent(self, mouse_event):
		if mouse_event.button() == QtCore.Qt.RightButton:
			selected_idx_list = self.selectionModel().selectedRows(0)
			for selected_idx in selected_idx_list:
				item = self.model().itemFromIndex(selected_idx)
				variant_obj = item.data(QtCore.Qt.UserRole)
				user_data = variant_obj.toPyObject()
		return super(MyTreeView, self).mouseReleaseEvent(mouse_event)

class MainWindow(QtGui.QWidget):
	def __init__(self, app):
		QtGui.QWidget.__init__(self)
		self.m_model = MyTreeModel(self, TEST_NODE)
		self.m_treeview = MyTreeView(self)
		self.m_treeview.setModel(self.m_model)
		self.m_treeview.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
		self.m_treeview.setSelectionMode(QtGui.QAbstractItemView.SingleSelection)
		self.resize(1024, 550)

class TestApp(QtGui.QApplication):
	def __init__(self, arg):
		super(TestApp, self).__init__(arg)

	def init(self):
		self.setStyleSheet(qdarkstyle.load_stylesheet_pyqt())
		self.main_window = MainWindow(self)
		self.main_window.show()

def main():
	APP = TestApp(sys.argv)
	APP.init()
	sys.exit(APP.exec_())

if __name__ == "__main__":
	main()