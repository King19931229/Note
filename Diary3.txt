【2018-03-06】【1】C#数据
对于结构赋值操作是拷贝内容
对于类则是增加引用技术
但是对于String却也是拷贝内容
struct ValueContain
{
	public int value;
};
或者
class ValueContain
{
	public int value;
};

// 对于结构可以省略 = new ValueContain();
ValueContain val = new ValueContain();
val.value = 10;

ValueContain val2 = val;
val2.value = 20;

Console.WriteLine("{0}", val.value);

结构输出的是10 类输出的是20


String str = "A";
String str2 = str;
str2 = "B";

Console.WriteLine("{0}", str);
输出 A

【2018-03-06】【2】C# Region
仅仅用于编辑器折叠代码使用
#region MyRegion
#endregion

【2018-03-06】【3】Python argparse
# https://www.jianshu.com/p/fef2d215b91d
import argparse

# 1.新建一个解析器
parser = argparse.ArgumentParser(
	# description 可选
	description="test case"
)

# 2.添加一个名字为arg0的定位参数
parser.add_argument("arg0")

# 3.添加一个可选参数
一种是通过一个-来指定的短参数 如-h
一种是通过--来指定的长参数 如--help
parser.add_argument("-v", "--verbosity")
# 注意如果长短参数同时存在则
# 通过 args = parser.parse_args() 访问 args 的参数成员只能用长参数访问 args.verbosity

# 4.避开设定值
parser.add_argument("-v", "--verbose", action="store_true")
# 这样指定参数时就不能设定参数值并且参数值为true 如果action="store_false"则参数值为false

# 5.设定值类型
parser.add_argument("x", type=int)
# 这样值类型不为int则报错

# 6.设定值范围
parser.add_argument("x", type=int, choices=[1,2,3])
# 这样值不为 1 or 2 or 3 则报错

# 7.添加help信息
parser.add_argument("x", type=int, help="args help")

# 8.设定默认参数
parser.add_argument("-v", "--verbose", default=1)
# 这样值不被指定时将会用默认值1 注意只能对可选参数使用

# *9.设置互斥参数
group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", action="store_true")
group.add_argument("-q", "--quiet", action="store_true")
# 这样 -v 和 -q 不能同时出现

【2018-03-07】SimplePref使用
// http://www.jishux.com/plus/view-672770-1.html
// https://zhuanlan.zhihu.com/p/25277481
// http://www.dpull.com/blog/2018-02-22-simpleperf
// https://developer.android.com/ndk/guides/simpleperf.html
下载最新的NDK 目录里有个simpleperf文件夹 运行里面的app_profiler.py进行剖析
如: python app_profiler.py -p com.xxx.yyy.zzz -nc -r "--duration 10 -g --call-graph dwarf" -nb
生成perf.data文件 运行report.py进行分析
如: python report.py --full-callgraph -g caller --gui --children

【2018-04-02】【1】Python面向对象
# http://www.runoob.com/python/python-object.html
# 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称 按照惯例它的名称是 self
例子:
#coding=utf-8
class Test:
	# 类文档
	'Test Class'
	# 类变量 相当于C++类静态变量
	count = 0

	# 通常传入的第一个参数叫self 这里为了突出self不是关键字
	# 起名为address
	def __init__(address, name):
		print address
		# 新增一个对象属性
		address._name = name
		Test.count += 1

	def PrintName(self):
		print self._name

	def ModifyName(self, name):
		# 修改一个对象属性
		self._name = name

	def DeleteName(self):
		# 删除一个对象属性
		del self._name

# 实例化对象 隐式传入对象地址作为__init__的第一个参数
t0 = Test("Test")

t0.ModifyName("ModifyName")
t0.PrintName()
t0.DeleteName()

# t0.PrintName()

# 输出类变量
print Test.count

【2018-04-02】【2】Python面向对象
# http://www.runoob.com/python/python-object.html
# 你也可以使用以下函数的方式来访问属性:
# getattr(obj, name[, default]): 访问对象的属性
# hasattr(obj,name): 检查是否存在一个属性
# setattr(obj,name,value): 设置一个属性 如果属性不存在 会创建一个新属性
# delattr(obj, name): 删除属性

例子:
#coding=utf-8
class Test:
	# 类文档
	'Test Class'
	# 类成员 相当于C++类静态变量
	count = 0

	# 通常传入的第一个参数叫self 这里为了突出self不是关键字
	# 起名为address
	def __init__(address, name):
		print address
		# 新增一个对象属性
		address._name = name
		Test.count += 1

t0 = Test("Name")

# 输出True
print hasattr(t0, "_name")
# 输出False
print hasattr(t0, "_age")

# 输出Name
print getattr(t0, "_name")
# 报错不存在属性_age
# print getattr(t0, "_age")

# 删除属性_name
delattr(t0, "_name")

# 报错不存在属性_age)
# delattr(t0, "_age"

setattr(t0, "_name", "NewName")

# 不存在属性_age 输出Name 避免抛出异常
print getattr(t0, "_age", "Name")

【2018-04-03】【1】Python继承
# http://www.runoob.com/python/python-object.html
1.在继承中基类的构造(__init__()方法)不会被自动调用 它需要在其派生类的构造中亲自专门调用
2.在调用基类的方法时 需要加上基类的类名前缀 且需要带上self参数变量
3.Python总是首先查找对应类型的方法(或成员) 如果它不能在派生类中找到对应的方法(或成员) 它才开始到基类中逐个查找

例子:
class Base:
	def __init__(self):
		print "Base __init__ call"

	def __del__(self):
		print "Base __del__ call"

	def Func(self):
		print "Base Func"

class Derived(Base):
	def __init__(self):
		print "Derived __init__ call"

	def __del__(self):
		print "Derived __del__ call"

	# 重写基类函数
	def Func(self):
		print "Derived Func"

# 只调用到派生类的构造函数
# derived = Derived()

class Derived_2(Base):
	count = 0

	def __init__(self):
		Base.__init__(self)
		Derived_2.count += 1
		print "Derived_2 __init__ call"

	def __del__(self):
		# 函数可能无法被调用 垃圾回收时 类被销毁了
		# Base.__del__(self)
		# 类成员可能无法使用 垃圾回收时 类被销毁了
		# print Base.count
		# Derived_2.count -= 1
		print "Derived_2 __del__ call"

	# 运算符重载
	def __str__(self):
		return "Derived_2 toStr"

	# 重写基类函数
	def Func(self):
		print "Derived_2 Func"

derived2 = Derived_2()
derived2.Func()

【2018-04-03】【2】Python面向对象
# http://www.runoob.com/python/python-object.html
1.对象变量
单下划线、双下划线、头尾双下划线说明：
__foo__: 定义的是特殊方法，一般是系统定义名字  类似 __init__() 之类的
_foo: 以单下划线开头的表示的是 protected 类型的变量 即保护类型只能允许其本身与子类进行访问 不能用于 from module import *
__foo: 双下划线的表示的是私有类型(private)的变量 只能是允许这个类本身进行访问了

2.类属性与方法
类的私有属性
__private_attrs: 两个下划线开头 声明该属性为私有 不能在类的外部被使用或直接访问 在类内部的方法中使用时 self.__private_attrs

类的方法
在类的内部 使用 def 关键字可以为类定义一个方法 与一般函数定义不同 类方法必须包含参数 self 且为第一个参数

类的私有方法
__private_method: 两个下划线开头 声明该方法为私有方法 不能在类地外部调用 在类的内部调用 self.__private_methods

【2018-04-03】【3】Python模块与包
# http://www.runoob.com/python/python-modules.html
# https://www.cnblogs.com/jiaxin359/p/7580375.html
# https://blog.csdn.net/luo123n/article/details/49849649
模块(Module): 是一个 Python 文件以 .py 结尾 包含了Python对象定义和Python语句
包(Package): 是文件夹 但该文件夹下必须存在 __init__.py 文件用于标识当前文件夹是一个包

例子:
目录结构
package/
	subpackage/
		__init__.py
		__main__.py
		subfile.py
		subfile2.py
	__init__.py
	__main.py
	main.py

在与package同级目录下package是一个包 package.subpackage也是一个包
package有模块main.py
package.subpackage有模块 subfile.py subfile2.py

python有两种加载文件的方法 一种是作为顶层的脚本
另一种时当做模块 如果你直接执行这个程序 那么这个文件就被当做是顶层脚本来执行了
__name__的值为模块名 顶层脚本的__name__为 __main__

模块内引用其他模块用import
如果你输入python -m myfile.py或者在其他的文件当中使用import来导入这个文件的时候 它就被当做模块来导入

相对import
subfile.py :
#coding=utf-8
# 绝对引用subfile2
import subfile2 [as newspace]
# 相对引用 一个.表示同级路径 ..表示更上一级
from . import subfile2 [as newspace]

相对引用不能用于顶层脚本 只能用于模块
如果使用相对引用 执行python package/subpackage/subfile.py报错
ValueError: Attempted relative import in non-package

可以使用python -m package.subpackage.subfile -m参数告诉python把它当做一个模块来加载 而不是顶层的脚本
如果被执行的不是模块而是一个包 则需要包内有命名为__main__.py的文件

【2018-04-03】【4】Sublime Text Project
// http://www.cnblogs.com/easy-blue/p/7840885.html
1. 创建工程 Project > Add Folder to Project
2. 保存工程 Project > Save Project As
菜单栏如果隐藏了点击Alt重新弹出

【2018-04-04】【1】Python异常
1.
try:
	可能抛出异常代码
except: #抛出异常进入此分支
	异常处理代码
else: #无抛出异常进入分支
	非异常执行代码

2.
try:
	可能抛出异常代码
finally:
	无论是否异常都会进入分支

3.自定义异常
class MyException(Exception):
	def __init__(self, param):
		self.agrs = str(param)

例子:
1.
try:
	if len(profit) != len(rate):
		# 手动促发异常
		raise Exception ("length wrong", "ERROR")
	# arg 为异常参数
	# 才此为 ("length wrong", "ERROR")
except Exception, arg:
	print "Excetion catch", arg
else:
	pass

2.
class MyException(Exception):
	def __init__(self, param):
		self.agrs = str(param)

try:
	if len(profit) == len(rate):
		raise MyException("ERROR")
	# 捕获自定义异常 instance为异常实例
except Exception as instance:
	print "Excetion catch", instance.args

3.
try:
	if len(profit) != len(rate):
		raise Exception('length wrong', "ERROR")
	else:
		print "no error"
finally:
	print "finally call"

【2018-04-04】【2】Python序列化对象
# https://www.cnblogs.com/shixisheng/p/7089930.html
根据python官方文档的定义 一个序列对象不必要保存所有的元素
一般来说 一个序列对象至少需要实现如下两个方法:
1. __len__方法 该方法返回序列长度 也即序列中元素个数。
2. __getitem__方法 该方法有一个整型参数(index) 它需要返回序列中下标为index的元素的值

例子：
class MyRange(object):
	def __init__(self, beg, end, step):
		self._beg = beg
		self._end = end
		self._step = step
		self._count = end - beg

	# 序列化对象必须实现__len__方法
	def __len__(self):
		return self._count

	# 序列化对象必须实现__getitem__方法
	def __getitem__(self, index):
		index = index if index >= 0 else self._count + index
		return self._beg + index * self._step

myRange = MyRange(0, 10, 1)
# 输出 3
print myRange[3]
# 输出 10
print len(myRange)

range方法返回的是一个list对象 它需要开辟专门的空间保存序列中所有的元素
xrange方法返回的是xrange对象 它是一个序列对象 但并不保存序列中的元素
其实现方法与MyRange类型类似
在python3.x中 xrange函数已经不复存在了

【2018-04-04】【3】Python for if
Python里面有一种for if 组合的用法比较特别
例如:
1.判断字符串里有无空格
str = 'i am ok'
# 进入else分支输出 no space in string
# str = "hello"
for i in xrange(0, len(str)):
	ch = str[i]
	if ch.isspace():
	 	break;
# 如果循环正常执行完毕将会进入else分支
else:
	print "no space in string"

2.判断100以内的素数
for n in range(2, 101):
	m = int(math.sqrt(n)) + 1
	for k in range(2, m):
		if n % k == 0:
			break;
	else:
		print n
		
【2018-04-04】【4】Python 函数变量
1.Python函数内部的变量为局部变量 如果想要引用到全局变量需要使用global声明
例:
def func():
	global callCount # = 0 编译失败 Python允许在声明全局变量同时赋值
	callCount += 1

callCount = 0
func()
func()
func()
# 输出 3
print callCount

2.Python函数内部变量不具有记忆性 相当于C++的栈变量
例:
def func():
	callCount = 0
	callCount += 1
	print callCount

# 三次都是输出1
func()
func()
func()

【2018-04-04】【5】Python 类变量与实例变量
Python里不对实例化对象的变量初始化将会使用类同名变量的值初始化
例:
class MyClass:
	count = 10
	def __init__(self):
		# 不对实例化对象的count初始化
		# self.count的值会用类同名变量的值初始化
		# self.count = 0
		pass

	def call(self):
		self.count += 1
		print "self.count: ", self.count

myClass = MyClass()

# 输出 10
print "myClass.count", myClass.count

# 输出 11 如果在__init__对count赋值为0 输出为 1
myClass.call()
# 输出 12 如果在__init__对count赋值为0 输出为 2
myClass.call()
# 输出 13 如果在__init__对count赋值为0 输出为 3
myClass.call()

# 输出 10
print "MyClass.count", MyClass.count

【2018-04-04】【6】Python三元表达式
格式: valForTrue if 条件为真 else valForFalse
max = lambda a, b: a if a > b else b
min = lambda a, b: b if a > b else b

【2018-04-04】【7】Python函数传参
# https://www.cnblogs.com/loleina/p/5276918.html
Python不允许程序员选择采用传值还是传引用
如果函数收到的是一个可变对象(比如字典或者列表) 就能修改对象的原始值 相当于通过"传引用"来传递对象
如果函数收到的是一个不可变对象(比如数字 字符串或者元组) 就不能直接修改原始对象 相当于通过"传值"来传递对象。
例:
def func(num):
	num *= 2

class NumContainer:
	def __init__(self, num):
		self.num = num

def funContainer(container):
	container.num *= 2

num = 10
func(num)
# 输出10
print num

container = NumContainer(10)
# 输出20
funContainer(container)
print container.num

又如：
def func(str):
	str = "newString"

str = "oldString"
# 输出oldString
func(str)
print str