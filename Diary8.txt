【2019-08-03】WPF Style
要在WPF某个控件上应用Style，如果在声明Style的时候指明Key则必须在
具体控件的Style上BaseOn这个带有Key的基础Style。
如果声明这个Style的时候没有指明Key，则该Style会全局被应用上。
例:
1.有效方式
<Style TargetType="{x:Type Control}" x:Key="FontBase">
	<Setter Property="FontFamily" Value="{StaticResource Tahoma Bold}"></Setter>
</Style>

<Style TargetType="{x:Type Label}" BasedOn="{StaticResource ResourceKey=FontBase}"></Style>

2.无效方式
<Style TargetType="{x:Type Label}" x:Key="FontBase">
	<Setter Property="FontFamily" Value="{StaticResource Tahoma Bold}"></Setter>
</Style>

3.有效方式
<Style TargetType="{x:Type Label}">
	<Setter Property="FontFamily" Value="{StaticResource Tahoma Bold}"></Setter>
</Style>

【2019-08-10】python import
# https://www.cnblogs.com/tp1226/p/8453854.html
# https://www.cnblogs.com/lzc978/p/10105194.html
1.from [package] import * 相当于把pakcage里面__init__.py的内容拷贝到import者py文件执行
例:
.
	|--subpackage0
	|	|--__init__.py
	|	|--module10.py
	|--main.py

【__init__.py】
print "[package] [{}] is imported".format(__name__)
import module10
import module11

【module10.py】
def func():
	print "module0"

【main.py】
from subpackage0 import *
module10.func()

输出:
[package] [subpackage0] is imported
module0


2.在package里面的__init__.py 里声明并赋值__all__变量会在from [package] import *的时候将
__init__.py里面__all__变量的模块在import者py文件都执行一次import
例:
.
	|--subpackage0
	|	|--__init__.py
	|	|--module10.py
	|--main.py

【__init__.py】
print "[package] [{}] is imported".format(__name__)
__all__ = ['module10']

【module10.py】
def func():
	print "module0"

【main.py】
from subpackage0 import *
module10.func()

输出:
[package] [subpackage0] is imported
module0


3.from [module] import * 相当于把module里面的对象拷贝（注意非引用）到import者py文件
例:
.
	|--testmodule.py
	|--main.py

【testmodule.py】
print "[module] [{}] imported".format(__name__)

message = 'i am module: {}'.format(__name__)

【main.py】
from testmodule import *

print "output message inside testmodule"
print message

message = 'i am main'
import testmodule
print "message inside testmodule remains unchanged"
print testmodule.message

testmodule.message = message
print "message inside testmodule changes"
print testmodule.message

输出:
[module] [testmodule] imported
output message inside testmodule
i am module: testmodule
message inside testmodule remains unchanged
i am module: testmodule
message inside testmodule changes
i am main

4.from module import [object] 相当于把module里面的object拷贝（注意非引用）到import者py文件
例:
.
	|--testmodule.py
	|--main.py

【testmodule.py】
print "[module] [{}] imported".format(__name__)

message = 'i am module: {}'.format(__name__)

【main.py】
from testmodule import message

print "output message inside testmodule"
print message

message = 'i am main'
import testmodule
print "message inside testmodule remains unchanged"
print testmodule.message

testmodule.message = message
print "message inside testmodule changes"
print testmodule.message

输出:
[module] [testmodule] imported
output message inside testmodule
i am module: testmodule
message inside testmodule remains unchanged
i am module: testmodule
message inside testmodule changes
i am main


5.import [package].[module] 或者 import [package] 都会把package里面__init__.py的内容执行一次
（package被首次import __init__.py的内容会被执行一次）
例:
.
	|--subpackage0
	|	|--__init__.py
	|	|--module10.py
	|--main.py

【__init__.py】
print "[package] [{}] is imported".format(__name__)

【module10.py】
print "[module] [{}] imported".format(__name__)
def func():
	print "module0"

【main.py】
import subpackage0.module10

输出:
[package] [subpackage0] is imported
[module] [subpackage0.module10] imported


6.只有import [package].module (as ...)或者 import [package] (as ...)语法 没有 import ([package].)[module].[object] (as ...)语法
例:
.
	|--subpackage0
	|	|--__init__.py
	|	|--module10.py
	|--testmodule.py
	|--main.py

【__init__.py】
print "[package] [{}] is imported".format(__name__)

【module10.py】
print "[module] [{}] imported".format(__name__)

message = 'i am module: {}'.format(__name__)

【testmodule.py】
print "[module] [{}] imported".format(__name__)

message = 'i am module: {}'.format(__name__)

【main.py】
import testmodule as m
import subpackage0 as p

try:
	import testmodule.message
except:
	import traceback
	traceback.print_exc()

try:
	import subpackage0.module10.message
except:
	import traceback
	traceback.print_exc()

输出:
[module] [testmodule] imported
[package] [subpackage0] is imported
Traceback (most recent call last):
  File "D:\Test\main.py", line 5, in <module>
    import testmodule.message
ImportError: No module named message
[module] [subpackage0.module10] imported
Traceback (most recent call last):
  File "D:\Test\main.py", line 11, in <module>
    import subpackage0.module10.message
ImportError: No module named message
[Finished in 0.1s]

【2019-08-11】【1】WPF RoutedEvent
// https://docs.microsoft.com/zh-tw/dotnet/framework/wpf/advanced/routed-events-overview
// https://www.cnblogs.com/JerryWang1991/archive/2013/03/29/2981103.html
WPF RoutedEvent用于在WPF控件层次结构中传递事件
例:
<Window x:Class="MiniWindow.RouteEventTest"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:local="clr-namespace:MiniWindow"
        Title="RouteEventTest" Height="300" Width="300"
		>
	<StackPanel x:Name="Panel">
		<Button Content="Button" x:Name="Button"></Button>
	</StackPanel>
</Window>

public partial class RouteEventTest : Window
{
	/// <summary>
	/// Tunnel Event
	/// 该Event将从层次结构中的上层对象往下层对象传递
	/// </summary>
	public static readonly RoutedEvent TunnelEvent = EventManager.RegisterRoutedEvent(
	"Tunnel", RoutingStrategy.Tunnel, typeof(RoutedEventHandler), typeof(RouteEventTest));

	// Provide CLR accessors for the event
	public event RoutedEventHandler Tunnel
	{
		add { AddHandler(TunnelEvent, value); }
		remove { RemoveHandler(TunnelEvent, value); }
	}

	/// <summary>
	/// Bubble Event
	/// 该Event将从层次结构中的下层对象往上层对象传递
	/// </summary>
	public static readonly RoutedEvent BubbleEvent = EventManager.RegisterRoutedEvent(
	"Bubble", RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(RouteEventTest));

	// Provide CLR accessors for the event
	public event RoutedEventHandler Bubble
	{
		add { AddHandler(BubbleEvent, value); }
		remove { RemoveHandler(BubbleEvent, value); }
	}

	/// <summary>
	/// DirectEvent
	/// 该Event将直接传递到目标对象
	/// </summary>
	public static readonly RoutedEvent DirectEvent = EventManager.RegisterRoutedEvent(
	"Direct", RoutingStrategy.Direct, typeof(RoutedEventHandler), typeof(RouteEventTest));

	// Provide CLR accessors for the event
	public event RoutedEventHandler Direct
	{
		add { AddHandler(DirectEvent, value); }
		remove { RemoveHandler(DirectEvent, value); }
	}

	public RouteEventTest()
	{
		InitializeComponent();

		// Add handler for window
		RoutedEventHandler windowHandler = new RoutedEventHandler((sender, e) =>
		{
			MessageBox.Show("Window receive event");
		});
		this.AddHandler(TunnelEvent, windowHandler);
		this.AddHandler(BubbleEvent, windowHandler);
		this.AddHandler(DirectEvent, windowHandler);

		// Add handler for panel
		RoutedEventHandler panelHandler = new RoutedEventHandler((sender, e) =>
		{
			MessageBox.Show("Panel receive event");
		});
		Panel.AddHandler(TunnelEvent, panelHandler);
		Panel.AddHandler(BubbleEvent, panelHandler);
		Panel.AddHandler(DirectEvent, panelHandler);

		// Add handler for button
		RoutedEventHandler buttonHandler = new RoutedEventHandler((sender, e) =>
		{
			MessageBox.Show("Button receive event");
		});
		Button.AddHandler(TunnelEvent, buttonHandler);
		Button.AddHandler(BubbleEvent, buttonHandler);
		Button.AddHandler(DirectEvent, buttonHandler);

		// https://stackoverflow.com/questions/11336140/handle-tunneled-custom-routed-event
		// 发起TunnelEvent 发起对象为Tunnel传递的终点
		// 第一个参数为要发起的event 第二个参数将赋值到event处理函数中RoutedEventArgs的OriginalSource
		Button.RaiseEvent(new RoutedEventArgs(TunnelEvent, this));

		// 发起BubbleEvent 发起对象为Bubble传递的起点
		// 第一个参数为要发起的event 第二个参数将赋值到event处理函数中RoutedEventArgs的OriginalSource
		Button.RaiseEvent(new RoutedEventArgs(BubbleEvent, Button));

		// 发起DirectEvent 发起对象为Direct的起点和终点
		// 第一个参数为要发起的event 第二个参数将赋值到event处理函数中RoutedEventArgs的OriginalSource
		Button.RaiseEvent(new RoutedEventArgs(DirectEvent, Button));
	}
}

输出:
"Window receive event"
"Panel receive event"
"Button receive event"

"Button receive event"
"Panel receive event"
"Window receive event"

"Button receive event"

【2019-08-11】【2】WPF ControlTemplate
WFP ControlTemplate用于重建控件样式,同时可以设置触发器响应控件属性更变
例:
<Window x:Class="MiniWindow.ControlTemplateTest"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:local="clr-namespace:MiniWindow"
        Title="ControlTemplateTest" Height="330" Width="300"
		>

	<Window.Resources>
		<!-- assign a style for reusing -->
		<Style x:Key="RedButtonStyle" TargetType="{x:Type Button}">
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate TargetType="{x:Type Button}">
						<ControlTemplate.Triggers>
							<Trigger Property="IsMouseOver" Value="True">
								<!-- the behavour is to set the Foreground property into Yellow -->
								<Setter Property="Foreground" Value="Yellow"></Setter>
							</Trigger>
						</ControlTemplate.Triggers>

						<Grid>
							<Ellipse Fill="Red" Width="150" Height="100"/>
							<ContentPresenter VerticalAlignment="Center" HorizontalAlignment="Center"/>
						</Grid>
					</ControlTemplate>
				</Setter.Value>
			</Setter>
		</Style>

		<!-- assign a template for reusing -->
		<ControlTemplate x:Key="GreenButtonTemplate" TargetType="{x:Type Button}">
			<ControlTemplate.Triggers>
				<!-- the trigger will work when the [property] of the button is IsMouseOver
						and [value] is True	-->
				<Trigger Property="IsMouseOver" Value="True">
					<!-- the behavour is to set the Foreground property into Yellow -->
					<Setter Property="Foreground" Value="Yellow"></Setter>
				</Trigger>
			</ControlTemplate.Triggers>

			<Grid>
				<Ellipse Fill="Green" Width="150" Height="100"/>
				<ContentPresenter VerticalAlignment="Center" HorizontalAlignment="Center"/>
			</Grid>
		</ControlTemplate>
	</Window.Resources>

	<StackPanel>
		<!-- setup Template property inside a button-->
		<Button Content="BlueButton" Click="Button_Click">
			<Button.Template>
				<!-- setup the TargetType to help the ContentPresenter show the content-->
				<ControlTemplate TargetType="{x:Type Button}">
					<!-- setup triggers to make hover effect-->
					<ControlTemplate.Triggers>
						<!-- the trigger will work when the [property] of the button is IsMouseOver
						and [value] is True	-->
						<Trigger Property="IsMouseOver" Value="True">
							<!-- the behavour is to set the Foreground property into Yellow -->
							<Setter Property="Foreground" Value="Yellow"></Setter>
						</Trigger>
					</ControlTemplate.Triggers>

					<Grid>
						<Ellipse Fill="Blue" Width="150" Height="100"/>
						<ContentPresenter VerticalAlignment="Center" HorizontalAlignment="Center"/>
					</Grid>
				</ControlTemplate>
			</Button.Template>
		</Button>

		<!-- setup Style property inside a button-->
		<Button Content="RedButton" Click="Button_Click" Style="{StaticResource RedButtonStyle}"/>

		<!-- setup Template property inside a button-->
		<Button Content="GreenButton" Click="Button_Click" Template="{StaticResource GreenButtonTemplate}"/>
	</StackPanel>
</Window>

public partial class ControlTemplateTest : Window
{
	public ControlTemplateTest()
	{
		InitializeComponent();
	}

	private void Button_Click(object sender, RoutedEventArgs e)
	{
		MessageBox.Show("I am clicked");
	}
}

【2019-08-11】【3】WPF DataTemplate
WFP DataTemplate用于重建控件Content属性的显示方式
例:
<Window x:Class="MiniWindow.DataTemplateTest"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:local="clr-namespace:MiniWindow"
        Title="DataTemplateTest" Height="330" Width="300"
		>

	<Window.Resources>
		<!-- assign a style for reusing -->
		<Style x:Key="LabelTemplateStyle" TargetType="{x:Type ContentControl}">
			<Setter Property="ContentTemplate">
				<Setter.Value>
					<DataTemplate>
						<Label Content="{Binding Text}"></Label>
					</DataTemplate>
				</Setter.Value>
			</Setter>
		</Style>
		<!-- assign a dataTemplate for reusing -->
		<DataTemplate x:Key="TextBlockTemplate">
			<TextBlock Text="{Binding Text}"></TextBlock>
		</DataTemplate>

	</Window.Resources>

	<StackPanel>
		<!-- setup the ContentTemplate property of a ContentControl -->
		<!-- https://stackoverflow.com/questions/24534021/wpf-datatemplate-binding -->
		<!-- setup binding for content to let DataTemplate able to bind attribute from the original binding source -->
		<ContentControl Content="{Binding ContainerA}">
			<ContentControl.ContentTemplate>
				<DataTemplate>
					<Button Content="{Binding Text}"></Button>
				</DataTemplate>
			</ContentControl.ContentTemplate>
		</ContentControl>

		<!-- setup the ContentTemplate property of by using Style -->
		<ContentControl Content="{Binding ContainerB}" Style="{StaticResource LabelTemplateStyle}"/>

		<!-- setup the ContentTemplate property of by using Template -->
		<ContentControl Content="{Binding ContainerC}" ContentTemplate="{StaticResource TextBlockTemplate}"/>

	</StackPanel>
</Window>

public partial class DataTemplateTest : Window, INotifyPropertyChanged
{
	public event PropertyChangedEventHandler PropertyChanged = (sender, e) => { };

	public class ContentContainer : INotifyPropertyChanged
	{
		public event PropertyChangedEventHandler PropertyChanged = (sender, e) => { };
		string _Text;
		public string Text
		{
			get
			{
				return _Text;
			}
			set
			{
				_Text = value;
				PropertyChanged(this, new PropertyChangedEventArgs("Text"));
			}
		}
	};

	ContentContainer _ContainerA;
	public ContentContainer ContainerA
	{
		get
		{
			return _ContainerA;
		}
		set
		{
			_ContainerA = value;
			PropertyChanged(this, new PropertyChangedEventArgs("ContainerA"));
		}
	}

	ContentContainer _ContainerB;
	public ContentContainer ContainerB
	{
		get
		{
			return _ContainerB;
		}
		set
		{
			_ContainerB = value;
			PropertyChanged(this, new PropertyChangedEventArgs("ContainerB"));
		}
	}

	ContentContainer _ContainerC;
	public ContentContainer ContainerC
	{
		get
		{
			return _ContainerC;
		}
		set
		{
			_ContainerC = value;
			PropertyChanged(this, new PropertyChangedEventArgs("ContainerC"));
		}
	}

	public DataTemplateTest()
	{
		InitializeComponent();
		// setup DataContext to this
		DataContext = this;

		ContainerA = new ContentContainer
		{
			Text = "TestButton"
		};

		ContainerB = new ContentContainer
		{
			Text = "TestLabel"
		};

		ContainerC = new ContentContainer
		{
			Text = "TestTextBlock"
		};
	}
}